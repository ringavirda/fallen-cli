<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <!-- FCli strings -->
  <!-- 
    
    All help messages 
    
    -->
  <data name="Basic_Help" xml:space="preserve">
    <value>Этот инструмент может запоминать действия а потом повторять их.
Сейчас поддерживает такие виды комманд:
    Url
    Script
    Executable

Использование:
    fcli &lt;tool?&gt; [params ...] [flags ...]

    fcli add C:\Awesome --exe --name awe
    fcli awe

Чтобы получить больше информации про этот инструменту используйсте флаг --help.
Команды, которые выводят список всех команд/инструментов:
    fcli list
    fcli list --tool</value>
  </data>
  <data name="Full_Help" xml:space="preserve">
    <value>Этот инструмент может быть использован для того, чтобы запоминать приложения, сайты, скрипты, и позже вызывать их по команде. Это должно быть полезным при использовании командной строки.

Синтаксис:
    fcli &lt;tool/command&gt; [flags...]

Инструменты:
    Инструменты управляют хранилищем команд и дополнительными функциями FCli.

    add    - добавляет новые команды в хранилище.
    remove - удаляет известные команды.
    list   - выводит состояние хранилища.
    run    - виполняет даную команду без валидации и не сохраняя её.

    Более детальную информацию об каждом инструменте можно получить использовав на
    нём флаг --help. Он выведет более подробное описание этого инструмента.

Команды:
    Если аргумент не является одним из известных селекторов инструментов, то он рассматривается как команда. Если эта комнда находится в хранилише, то FCli реконструирует её и попытается выполнить наиболее подходящим образом.
    Все сохранённые команды можно вывести используя инструмент list.

Использование:
    fcli add c:\awesome --exe -name aw
    fcli aw --options "-s 2"
    fcli remove aw
    fcli add https://google.com --name google
    fcli google</value>
  </data>
  <data name="Add_Help" xml:space="preserve">
    <value>Add - валидирует указаные свойства команды и добавляет её в хранилище. Требует существующий путь или корректную ссылку как аргумент.
Флаги:
    --script &lt;shell&gt; - путь указывает на скриптовый файл.
    --exe            - путь ведёт к выполняемому файлу.
    --url            - аргумент это ссылка на сайт.
    --name &lt;value&gt;   - указывает конкретное имя для команды.
    --options &lt;args&gt; - дополнительные аргументы кмандой строки.
    --help           - показывает эту страницу.
Использование:
    fcli add c:/awesome.exe
    fcli add .\scripts\script --script bash --name sc</value>
  </data>
  <data name="List_Help" xml:space="preserve">
    <value>List - выводит в консоль списки известных команд/инструментов зависимо от указанных флагов. Выводит все команды, если флаги не указаны.
Флаги:
    --script - добавляет скрипты в список.
    --exe    - добавляет исполняемые файлы в список.
    --url    - добавляет сайты в список.
    --tools  - выводит все известные селекторы инструментов.
    --help   - показывает эту страницу.
Использование:
    fcli list
    fcli list --tools
    fcli ls --script --url</value>
  </data>
  <data name="Remove_Help" xml:space="preserve">
    <value>Remove - удаляет команду из хранилища.
Флаги:
    --yes  - пропускает подтверждение.
    --all  - удаляет все команды (непропускаемое подтверждение).
    --help - показывает эту страницу.
Использование:
    fcli remove awesome --yes</value>
  </data>
  <data name="Run_Help" xml:space="preserve">
    <value>Run - выполняет даный путь или ссылку без валидации и сохранения. Полезно для тестирования. Требует путь или ссылку, а так же конктрено указаный тип команды через соответствующий флаг.
Флаги:
    --script &lt;shell&gt; - запустить как скрипт.
    --exe            - запустить как выполняемый файл.
    --url            - запустить как ссылку.
    --help           - показать эту страницу.
Использование:
    fcli run c:/awesome --script powershell
    fcli run https://awesome.com --url</value>
  </data>
  <data name="Config_Help" xml:space="preserve">
    <value>Config - позволяет управлять пользовательским конфигурационным файлом. Используя этот инструмент вы можете изменять некоторые значения, или же удалить конфигурационный файл целиком.
Флаги:
    --locale &lt;loc&gt;     - указывает культуру которую использовать.
        - поддерживаемые локали: en, ru, uk.
    --formatter &lt;type&gt; - устанавливает использоваемый форматировальщик.
        - inline       - склонен показывать сообщения одной строкой.
        - pretty       - более многословен, разноцвентный и многострочный.
    --purge            - удаляет существующую конфигурацию.</value>
Использование:
    fcli config
    fcli cnf --locale en --formatter pretty
    fcli config --purge</data>

  <!--

    Error messages

  -->

  <data name="FCli_CriticalError" xml:space="preserve">
    <value>Случилось что-то ужасное!
[{0}]: {1}</value>
  </data>
  <data name="FCli_UnknownShell" xml:space="preserve">
    <value>Флаг --script должен так же указывать окружение.
Поддерживаемые окружения: {0}.</value>
  </data>

  <!--

    Tool strings

  -->
  <data name="Tool_FlagShouldNotHaveValue" xml:space="preserve">
    <value>Флаг (--{0}) не должен иметь никакого значения.
Чтобы увидеть список всех поддерживаемых флагов для {1} воспользуйстесь страницой помощи указав флаг --help.</value>
  </data>
  <data name="Tool_FlagShouldHaveValue" xml:space="preserve">
    <value>Флаг (--{0}) должен иметь значение.
Чтобы увидеть список всех поддерживаемых флагов для {1} воспользуйстесь страницой помощи указав флаг --help.</value>
  </data>
  <data name="Tool_FlagIsUnknown" xml:space="preserve">
    <value>Флаг (--{0}) не есть флагом инструмента {1}.
Чтобы увидеть список всех поддерживаемых флагов для {1} воспользуйстесь страницой помощи указав флаг --help.</value>
  </data>
  <data name="Tool_UrlIsInvalid" xml:space="preserve">
    <value>({0}) - невалидныя ссылка.</value>
  </data>
  <data name="Tool_PathIsInvalid" xml:space="preserve">
    <value>({0}) - недействительный путь.</value>
  </data>
  <!--

    Add tool strings

  -->
  <data name="Add_NoArg" xml:space="preserve">
    <value>Инструмент Add требует аргумент - путь или ссылку.</value>
  </data>
  <data name="Add_MultipleTypeFlags" xml:space="preserve">
    <value>Инструмент Add может иметь только один флаг типа.</value>
  </data>
  <data name="Add_FileUnrecognized" xml:space="preserve">
    <value>Невозможно определить тип файла. Пожалуйста, укажите его используя флаг типа. Чтобы увидеть список всех флагов типа, воспользуйстесь --help.</value>
  </data>
  <data name="Add_CommandNotDetermined" xml:space="preserve">
    <value>Тип команды не был определён. FCli может распознать только путь или ссылку. Вы можете напрямую указать тип команды используя флаги типов. Страница помощи содержит больше информации.</value>
  </data>
  <data name="Add_NameAlreadyExists" xml:space="preserve">
    <value>Имя ({0}) - это известная команда или инструмент.
Вы можете использовать флаг --name чтобы указать другое имя для команды.</value>
  </data>
  <data name="Add_BashOnWindows" xml:space="preserve">
    <value>Команда ({0}) была распознана как Bash скрипт, но окружением сейчас является Windows. Bash скрипты могут быть выполнены на Windows, FCli использует WSL для этого. Вам нужно убедиться что ваша Windows имеет подсистему WSL установленую и с включённым стандартным дистрибутивом чтобы это сработало.</value>
  </data>
  <data name="Add_FishOnWindows" xml:space="preserve">
    <value>Команда ({0}) была распознана Fish скрипт, но окружением является операционная система Windows. Fish только поддерживается на Unix-подобных системах.</value>
  </data>
  <data name="Add_CmdOnLinux" xml:space="preserve">
    <value>Команда ({0}) была распознана как Бат файл, но окружением сейчас является операционная система Linux. CMD поддерживается только на Windows.</value>
  </data>
  <data name="Add_PowershellOnLinux" xml:space="preserve">
    <value>Команда ({0}) распознана как Powershell скрипт, но окружением сейчас является операционная система Linux. PS скрипты могут быть запущены на Linux, но powershell должен быть установлен используя ваш пакетный менеджер.</value>
  </data>
  <data name="Add_OSScript_Question" xml:space="preserve">
    <value>Вы уверены что ваша система может запустить этот тип скрипта?</value>
  </data>
  <data name="Add_OSScript_Avert" xml:space="preserve">
    <value>Отмена продеса add...</value>
  </data>
  <data name="Add_OSScript_Continue" xml:space="preserve">
    <value>Продолжаем процесс add...</value>
  </data>
  <data name="Add_ParsedCommand" xml:space="preserve">
    <value>Команда была реконструирована:
  name    - {0}
  type    - {1}
  shell   - {2}
  path    - {3}
  options - {4}</value>
  </data>
  <data name="Add_Saving" xml:space="preserve">
    <value>Сохранение в хранилище...</value>
  </data>
  <data name="Add_Saved" xml:space="preserve">
    <value>Сохранено.
Чтобы вызвать эту команду воспользуйтесь:
  fcli {0}</value>
  </data>
  <!--

    Config tool strings

  -->
  <data name="Config_Arg" xml:space="preserve">
    <value>Инструмент Config не может иметь никаких аргументов.
Чтобы увидеть информацию об инструменте Config воспользуйстесь страницей помощи, указав флаг --help.</value>
  </data>
  <data name="Config_ListConfig" xml:space="preserve">
    <value>Не указано никаких флагов, вывожу состояние конфигурации:</value>
  </data>
  <data name="Config_Formatter" xml:space="preserve">
    <value>Форатировщик: {0}</value>
  </data>
  <data name="Config_Locale" xml:space="preserve">
    <value>Локаль: {0}</value>
  </data>
  <data name="Config_UnknownLocale" xml:space="preserve">
    <value>Неподдерживаемая локаль была указана через флаг --locale.
Чтобы увидеть поддерживаемые локали воспользуйтесь страницей помощи.</value>
  </data>
  <data name="Config_LocaleChangeWarning" xml:space="preserve">
    <value>Смена локали с ({0}) на ({1})...</value>
  </data>
  <data name="Config_LocaleChanged" xml:space="preserve">
    <value>Локаль изменена.</value>
  </data>
  <data name="Config_UnsupportedFormatter" xml:space="preserve">
    <value>Неподдерживаемый форматировщик был указан через флаг --formatter.
Чтобы увидеть поддерживаемые форматировшики воспользуйтесь страницей помощи.</value>
  </data>
  <data name="Config_FormatterChangeWarning" xml:space="preserve">
    <value>Смена форматировщика командной строки с ({0}) на ({1})...</value>
  </data>
  <data name="Config_FormatterChanged" xml:space="preserve">
    <value>Форматировщик изменён.</value>
  </data>
  <data name="Config_PurgeWarning" xml:space="preserve">
    <value>Вы собираетесть удалить файл пользовательской конфигурации, все ваши установки будут утеряны. Вы уверены, что вы хотите продолжить?</value>
  </data>
  <data name="Config_PurgeAverted" xml:space="preserve">
    <value>Удаление конфигурации предотвращена.</value>
  </data>
  <data name="Config_Purging" xml:space="preserve">
    <value>Удаление конфигурацию...</value>
  </data>
  <data name="Config_Purged" xml:space="preserve">
    <value>Удалено.</value>
  </data>
  <!--

    List tool strings

  -->
  <data name="List_NoCommands" xml:space="preserve">
    <value>Сейчас в хранилище нет известных команд.</value>
  </data>
  <data name="List_ListAllCommands" xml:space="preserve">
    <value>Никаких флагов не указано, выводим все команды:</value>
  </data>
  <data name="List_ListCommands" xml:space="preserve">
    <value>Список всех команд типа ({0}):</value>
  </data>
  <data name="List_NoCommandsSelected" xml:space="preserve">
    <value>В системе не записано команд ({0}) типа.</value>
  </data>
  <data name="List_ToolArg" xml:space="preserve">
    <value>(--tool) не может иметь фильтр.</value>
  </data>
  <data name="List_Tools" xml:space="preserve">
    <value>Сисок всех известных селекторов инструментов:</value>
  </data>
  <data name="List_NothingFiltered" xml:space="preserve">
    <value>Не было найдено команд подходящих под фильтр: {0}</value>
  </data>
  <!--

    Remove tool strings

  -->
  <data name="Remove_InvalidArg" xml:space="preserve">
    <value>({0}) - не является известным именем команды.
Чтобы увидеть все имена команд попробуйте: fcli list.</value>
  </data>
  <data name="Remove_AllWarning" xml:space="preserve">
    <value>Флаг (--all): вы собираетесь удалить все команды из хранилища.
Вы уверены?</value>
  </data>
  <data name="Remove_NoCommands" xml:space="preserve">
    <value>В хранилище нет команд!</value>
  </data>
  <data name="Remove_AllDeleted" xml:space="preserve">
    <value>Все существующие команды были удалены.</value>
  </data>
  <data name="Remove_Averted" xml:space="preserve">
    <value>Удаление предотвращено.</value>
  </data>
  <data name="Remove_Deleting" xml:space="preserve">
    <value>Удаление...</value>
  </data>
  <data name="Remove_Warning" xml:space="preserve">
    <value>Команда ({0}) будет удалена.
Вы уверены?</value>
  </data>
  <data name="Remove_Deleted" xml:space="preserve">
    <value>Команда ({0}) была успешно удалена.</value>
  </data>
  <!--

    Run tool strings

  -->
  <data name="Run_NoArg" xml:space="preserve">
    <value>Вам нужно указать путь или ссылку которую вы хотите протестировать.
Чтобы увидеть использование Run укажите флаг --help.</value>
  </data>
  <data name="Run_MultipleTypeFlags" xml:space="preserve">
    <value>Инструмент Run не может имент несколько флагов типа.</value>
  </data>  
  <data name="Run_UnknownCommand" xml:space="preserve">
    <value>Тип команды не был распознан, пожалуйста, укажите его используя флаг типа.
Чтобы увидеть использование Run укажите флаг --help.</value>
  </data>
  <!--

    Command Factory strings

  -->
  <data name="Command_CmdOnWindows" xml:space="preserve">
    <value>Скрипты CMD не могут быть запущены на системах Linux!</value>
  </data>
  <data name="Command_PowershellOnLinux" xml:space="preserve">
    <value>Попытка запуска Powershell скрипта на Linux..</value>
  </data>
  <data name="Command_BashOnWindows" xml:space="preserve">
    <value></value>
  </data>
  <data name="" xml:space="preserve">
    <value></value>
  </data>
  
</root>