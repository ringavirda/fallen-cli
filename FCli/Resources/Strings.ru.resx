<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <!-- FCli strings -->
  <!-- 
    
    Help messages 
    
    -->
  <data name="Basic_Help" xml:space="preserve">
    <value>Этот инструмент может запоминать действия а потом повторять их.
Сейчас поддерживает такие виды команд:
    Url
    Script
    Executable
    Directory

Использование:
    fcli &lt;tool?&gt; [params ...] [flags ...]

    fcli add C:\Awesome --exe --name awe
    fcli awe

Чтобы получить больше информации про этот инструменту используйте флаг --help.
Команды, которые выводят список всех команд/инструментов:
    fcli list
    fcli list --tool</value>
  </data>
  <data name="Full_Help" xml:space="preserve">
    <value>Этот инструмент может быть использован для того, чтобы запоминать приложения, сайты, скрипты, и позже вызывать их по команде. Это должно быть полезным при использовании командной строки.

Синтаксис:
    fcli &lt;tool/command&gt; [flags...]

Инструменты:
    Инструменты управляют хранилищем команд и дополнительными функциями FCli.

    add    - добавляет новые команды в хранилище.
    remove - удаляет известные команды.
    list   - выводит состояние хранилища.
    run    - выполняет данную команду без валидации и не сохраняя её.
    config - изменяет пользовательскую конфигурацию.
    group  - создаёт выполняемые последовательности команди.
    change - изменяет существующую команду.

    Более детальную информацию об каждом инструменте можно получить использовав на
    нём флаг --help. Он выведет более подробное описание этого инструмента.

Команды:
    Если аргумент не является одним из известных селекторов инструментов, то он рассматривается как команда. Если эта команда находится в хранилище, то FCli реконструирует её и попытается выполнить наиболее подходящим образом.
    Все сохранённые команды можно вывести используя инструмент list.

Использование:
    fcli add c:\awesome --exe -name aw
    fcli aw --options "-s 2"
    fcli remove aw
    fcli add https://google.com --name google
    fcli google</value>
  </data>
  <!--

    Global messages

  -->
  <data name="FCli_Info_Inline" xml:space="preserve">
    <value>Инфо</value>
  </data>
  <data name="FCli_Info_Pretty" xml:space="preserve">
    <value>Передаёт вам информацию</value>
  </data>
  <data name="FCli_Warning_Inline" xml:space="preserve">
    <value>Внимание</value>
  </data>
  <data name="FCli_Warning_Pretty" xml:space="preserve">
    <value>Предупреждает вас об этом</value>
  </data>
  <data name="FCli_Error_Inline" xml:space="preserve">
    <value>Ошибка</value>
  </data>
  <data name="FCli_Error_Pretty" xml:space="preserve">
    <value>Во время выполнения команды возникла ошибка</value>
  </data>
  <data name="FCli_Progress_Inline" xml:space="preserve">
    <value>Выполняется</value>
  </data>
  <data name="FCli_Progress_Pretty" xml:space="preserve">
    <value>Операция в прогрессе: </value>
  </data>
  <data name="FCli_MultipleArgs" xml:space="preserve">
    <value>FCli принимает только [tool?] [arg], но было передано больше одного аргумента.</value>
  </data>
  <data name="FCli_CriticalError" xml:space="preserve">
    <value>Случилось что-то ужасное!
[{0}]: {1}</value>
  </data>
  <data name="FCli_UnknownShell" xml:space="preserve">
    <value>Флаг --script должен так же указывать окружение.
Поддерживаемые окружения: {0}.</value>
  </data>
  <data name="FCli_UnknownCommandType" xml:space="preserve">
    <value>({0}) - не есть известным типом команды.</value>
  </data>
  <data name="FCli_NameExists" xml:space="preserve">
    <value>({0}) - это имя известной команды или селектора инструмента.</value>
  </data>
  <data name="FCli_UnknownName" xml:space="preserve">
    <value>({0}) - не есть известным именем команды или группы.</value>
  </data>
  <data name="FCli_Confirm" xml:space="preserve">
    <value>Вы уверены, что хотите продолжить?</value>
  </data>
  <data name="FCli_Averted" xml:space="preserve">
    <value>Операция предотвращена.</value>
  </data>
  <data name="FCli_Cancelled" xml:space="preserve">
    <value>Операция отменена.</value>
  </data>
  <data name="FCli_Continued" xml:space="preserve">
    <value>Операция продолжается...</value>
  </data>
  <data name="FCli_ArgMissing" xml:space="preserve">
    <value>({0}) был вызван без аргумента.</value>
  </data>
  <data name="FCli_UnexpectedArg" xml:space="preserve">
    <value>({0}) не поддерживает аргумент, но получил его.</value>
  </data>
  <data name="FCli_MultipleTypeFlags" xml:space="preserve">
    <value>({0}) может принят только один флаг типа.</value>
  </data>
  <data name="FCli_CommandNotDetermined" xml:space="preserve">
    <value>Тип команды не был определён. FCli может распознать только путь или ссылку. Вы можете напрямую указать тип команды используя флаги типов. Страница помощи содержит больше информации.</value>
  </data>
  <data name="FCli_Saving" xml:space="preserve">
    <value>Запись в хранилище...</value>
  </data>
  <data name="FCli_CommandSaved" xml:space="preserve">
    <value>Сохранено.
Чтобы использовать команду/группу попробуйте:
        fcli {0}</value>
  </data>
  <!--

    Tool strings

  -->
  <data name="Tool_FlagShouldNotHaveValue" xml:space="preserve">
    <value>Флаг (--{0}) не должен иметь никакого значения.
Чтобы увидеть список всех поддерживаемых флагов для {1} воспользуйтесь страницей помощи указав флаг --help.</value>
  </data>
  <data name="Tool_FlagShouldHaveValue" xml:space="preserve">
    <value>Флаг (--{0}) должен иметь значение.
Чтобы увидеть список всех поддерживаемых флагов для {1} воспользуйтесь страницей помощи указав флаг --help.</value>
  </data>
  <data name="Tool_FlagIsUnknown" xml:space="preserve">
    <value>Флаг (--{0}) не есть флагом инструмента {1}.
Чтобы увидеть список всех поддерживаемых флагов для {1} воспользуйтесь страницей помощи указав флаг --help.</value>
  </data>
  <data name="Tool_UrlIsInvalid" xml:space="preserve">
    <value>({0}) - невалидная ссылка.</value>
  </data>
  <data name="Tool_PathIsInvalid" xml:space="preserve">
    <value>({0}) - недействительный путь.</value>
  </data>
  <!--

    Add tool strings

  -->
  <data name="Add_Help" xml:space="preserve">
    <value>Add - валидирует указанные свойства команды и добавляет её в хранилище. Требует существующий путь или корректную ссылку как аргумент.
Флаги:
    --script &lt;shell&gt; - путь указывает на скриптовый файл.
    --exe            - путь ведёт к выполняемому файлу.
    --url            - аргумент это ссылка на сайт.
    --dir            - путь ведёт к директории.
    --name &lt;value&gt;   - указывает конкретное имя для команды.
    --options &lt;args&gt; - дополнительные аргументы командой строки.
    --help           - показывает эту страницу.
Использование:
    fcli add c:/awesome.exe
    fcli add .\scripts\script --script bash --name sc</value>
  </data>
  <data name="Add_FileUnrecognized" xml:space="preserve">
    <value>Невозможно определить тип файла. Пожалуйста, укажите его используя флаг типа. Чтобы увидеть список всех флагов типа, воспользуйтесь --help.</value>
  </data>
  <data name="Add_BashOnWindows" xml:space="preserve">
    <value>Команда ({0}) была распознана как Bash скрипт, но окружением сейчас является Windows. Bash скрипты могут быть выполнены на Windows, FCli использует WSL для этого. Вам нужно убедиться что ваша Windows имеет подсистему WSL установленную и с включённым стандартным дистрибутивом чтобы это сработало.</value>
  </data>
  <data name="Add_FishOnWindows" xml:space="preserve">
    <value>Команда ({0}) была распознана Fish скрипт, но окружением является операционная система Windows. Fish только поддерживается на Unix-подобных системах.</value>
  </data>
  <data name="Add_CmdOnLinux" xml:space="preserve">
    <value>Команда ({0}) была распознана как Бат файл, но окружением сейчас является операционная система Linux. CMD поддерживается только на Windows.</value>
  </data>
  <data name="Add_PowershellOnLinux" xml:space="preserve">
    <value>Команда ({0}) распознана как Powershell скрипт, но окружением сейчас является операционная система Linux. PS скрипты могут быть запущены на Linux, но powershell должен быть установлен используя ваш пакетный менеджер.</value>
  </data>
  <data name="Add_OSScript_Question" xml:space="preserve">
    <value>Вы уверены что ваша система может запустить этот тип скрипта?</value>
  </data>
  <data name="Add_ParsedCommand" xml:space="preserve">
    <value>Команда была реконструирована:
  name    - {0}
  type    - {1}
  shell   - {2}
  path    - {3}
  options - {4}</value>
  </data>
  <!--

    Config tool strings

  -->
  <data name="Config_Help" xml:space="preserve">
    <value>Config - позволяет управлять пользовательским конфигурационным файлом. Используя этот инструмент вы можете изменять некоторые значения, или же удалить конфигурационный файл целиком.
Флаги:
    --locale &lt;loc&gt;     - указывает культуру которую использовать.
        Поддерживаемые локали: en, ru, uk.
    --formatter &lt;type&gt; - устанавливает используемый форматировщик.
        - inline       - склонен показывать сообщения одной строкой.
        - pretty       - более многословен, разноцветный и многострочный.
    --purge            - удаляет существующую конфигурацию.
    --help             - выводит эту страницу.</value>
Использование:
    fcli config
    fcli cnf --locale en --formatter pretty
    fcli config --purge</data>
  <data name="Config_ListConfig" xml:space="preserve">
    <value>Не указано никаких флагов, вывожу состояние конфигурации:</value>
  </data>
  <data name="Config_Formatter" xml:space="preserve">
    <value>Форматировщик: {0}</value>
  </data>
  <data name="Config_Locale" xml:space="preserve">
    <value>Локаль: {0}</value>
  </data>
  <data name="Config_UnknownLocale" xml:space="preserve">
    <value>Неподдерживаемая локаль была указана через флаг --locale.
Чтобы увидеть поддерживаемые локали воспользуйтесь страницей помощи.</value>
  </data>
  <data name="Config_LocaleChangeWarning" xml:space="preserve">
    <value>Смена локали с ({0}) на ({1})...</value>
  </data>
  <data name="Config_LocaleChanged" xml:space="preserve">
    <value>Локаль изменена.</value>
  </data>
  <data name="Config_UnsupportedFormatter" xml:space="preserve">
    <value>Неподдерживаемый форматировщик был указан через флаг --formatter.
Чтобы увидеть поддерживаемые форматировщики воспользуйтесь страницей помощи.</value>
  </data>
  <data name="Config_FormatterChangeWarning" xml:space="preserve">
    <value>Смена форматировщика командной строки с ({0}) на ({1})...</value>
  </data>
  <data name="Config_FormatterChanged" xml:space="preserve">
    <value>Форматировщик изменён.</value>
  </data>
  <data name="Config_PurgeWarning" xml:space="preserve">
    <value>Вы собираетесь очистить файл пользовательской конфигурации, все ваши установки будут утеряны. Вы уверены, что вы хотите продолжить?</value>
  </data>
  <data name="Config_Purged" xml:space="preserve">
    <value>Конфигурацию очищено.</value>
  </data>
  <!--

    List tool strings

  -->
  <data name="List_Help" xml:space="preserve">
    <value>List - выводит в консоль списки известных команд/инструментов зависимо от указанных флагов. Выводит все команды, если флаги не указаны.
Аргумент используется как фильтр для этого инструмента.
Флаги:
  Команды
    --script - добавляет скрипты в список.
    --exe    - добавляет исполняемые файлы в список.
    --url    - добавляет сайты в список.
    --dir    - добавляет директории в список.
  Специальные:
    --tools  - выводит известные селекторы инструментов.
    --shells - выводит поддерживаемые типы окружения.
    --types  - выводит известные типы команд.
    --groups - добавляет группы в список.
    --help   - показывает эту страницу.
Использование:
    fcli list
    fcli list --tools
    fcli ls --script --url</value>
  </data>
  <data name="List_NoCommands" xml:space="preserve">
    <value>Сейчас в хранилище нет известных команд.</value>
  </data>
  <data name="List_ListAllCommands" xml:space="preserve">
    <value>Никаких флагов не указано, выводим все команды:</value>
  </data>
  <data name="List_ListCommands" xml:space="preserve">
    <value>Список всех команд типа ({0}):</value>
  </data>
  <data name="List_NoCommandsSelected" xml:space="preserve">
    <value>В системе не записано команд ({0}) типа.</value>
  </data>
  <data name="List_Tools" xml:space="preserve">
    <value>Список всех известных селекторов инструментов:</value>
  </data>
  <data name="List_NothingFiltered" xml:space="preserve">
    <value>Не было найдено команд подходящих под фильтр: {0}</value>
  </data>
  <!--

    Remove tool strings

  -->
  <data name="Remove_Help" xml:space="preserve">
    <value>Remove - удаляет команду из хранилища.
Флаги:
    --yes  - пропускает подтверждение.
    --all  - удаляет все команды (непропускаемое подтверждение).
    --help - показывает эту страницу.
Использование:
    fcli remove awesome --yes</value>
  </data>
  <data name="Remove_AllWarning" xml:space="preserve">
    <value>Флаг (--all): вы собираетесь удалить все команды из хранилища.
Вы уверены?</value>
  </data>
  <data name="Remove_NoCommands" xml:space="preserve">
    <value>В хранилище нет команд!</value>
  </data>
  <data name="Remove_AllDeleted" xml:space="preserve">
    <value>Все существующие команды были удалены.</value>
  </data>
  <data name="Remove_Warning" xml:space="preserve">
    <value>Команда ({0}) будет удалена.
Вы уверены?</value>
  </data>
  <data name="Remove_Deleted" xml:space="preserve">
    <value>Команда ({0}) была успешно удалена.</value>
  </data>
  <!--

    Run tool strings

  -->
  <data name="Run_Help" xml:space="preserve">
    <value>Run - выполняет данный путь или ссылку без валидации и сохранения. Полезно для тестирования. Требует путь или ссылку, а так же конкретно указанный тип команды через соответствующий флаг.
Флаги:
    --script &lt;shell&gt; - запустить как скрипт.
    --exe            - запустить как выполняемый файл.
    --url            - запустить как ссылку.
    --dir            - открыть как директорию.
    --help           - показать эту страницу.
Использование:
    fcli run c:/awesome --script powershell
    fcli run https://awesome.com --url</value>
  </data> 
  <data name="Run_UnknownCommand" xml:space="preserve">
    <value>Тип команды не был распознан, пожалуйста, укажите его используя флаг типа.
Чтобы увидеть использование Run укажите флаг --help.</value>
  </data>
  <!--

    Command Factory strings

  -->
  <data name="Command_UnsupportedShell" xml:space="preserve">
    <value>({0}) не могут быть запущены на системах ({1})!</value>
  </data>
  <data name="Command_UnsupportedShellWarning" xml:space="preserve">
    <value>Попытка запуска ({0}) на ({1})...</value>
  </data>
  <!--
    
    Group tool strings
    
  -->
  <data name="Group_Help" xml:space="preserve">
    <value>Инструмент Group может собирать команды в выполняемые последовательности. Таким образом, вы можете указывать коллекции команд, которые будут выполнены.
Чтобы создать группу, вам нужно указать все команды в последовательности, которая вам нужна, разделив их пробелом и взяв в кавычки. (--name) флаг обязателен.
Этот инструмент может изменять группы используя флаги.
Флаги:
        --name &lt;name&gt;     - создаёт новую группу с этим именем.
        --remove           - удаляет оказанную команду (аргумент это имя группы в этом случае, подтверждение).
        --all              - вместе с remove удаляет все группы (подтверждение обязательно).
        --override &lt;name&gt; - изменяет последовательность указанной группы.
        --yes              - пропускает подтверждение.
        --help             - выводит эту страницу.
Использование:
        fcli group "cmd1 cmd2" --name mygr
        fcli gr "cmd1 cmd2 cmd3" --override mygr --yes
        fcli group mygr --remove</value>
  </data>
  <data name="Group_Constructed" xml:space="preserve">
    <value>Группа сконструирована:
name     - {0}
sequence - {1}</value>
  </data>
  <data name="Group_OverrideWarning" xml:space="preserve">
    <value>Вы намереваетесь перезаписать группу ({0}) указанной последовательностью.</value>
  </data>
  <data name="Group_RemoveAllWarning" xml:space="preserve">
    <value>Флаг All: вы намереваетесь удалить все известные группы команд.</value>
  </data>
  <data name="Group_RemovedAll" xml:space="preserve">
    <value>Все группы команд были удалены из хранилища.</value>
  </data>
  <data name="Group_NoGroups" xml:space="preserve">
    <value>Группы не были найдены!</value>
  </data>
  <data name="Group_Removed" xml:space="preserve">
    <value>Группа ({0}) была удалена.</value>
  </data>
  <data name="Group_NotAGroup" xml:space="preserve">
    <value>({0}) не является группой!</value>
  </data>
  <data name="" xml:space="preserve">
    <value></value>
  </data>
<!--
    
    Change tool strings
    
  -->
  <data name="Change_Help" xml:space="preserve">
    <value>Change - разрешает изменять известные команды.
Аргумент это всегда имя команды которую нужно изменить, а новые значения задаются через флаги. Чтобы изменять последовательности групп используйте инструмент group.
Внимание!!! Этот инструмент позволит изменить вам типы и имена - это может сломать как выполнение так и связанные группы. Так же он позволяет установит путь без валидации. Используйте этот инструмент с осторожностью.
Флаги:
      --name    - новое имя команды.
      --path    - новый путь.
      --type    - новый тип команды.
      --shell   - новый тип окружения.
      --options - новые опции командной строки.
      --help    - выводит эту страницу.
Использование:
      fcli change awesome --name newName --type script --shell bash
      fcli ch newName --type exe --path /new/path
    </value>
  </data>
  <data name="Change_ShowCommand" xml:space="preserve">
    <value>Не обнаружено флагов, вывожу состояние ({0}):</value>
  </data>
  <data name="Change_NameWarning" xml:space="preserve">
    <value>Зафиксировано изменение имени для команды ({0}).
Внимание: Это может сломать группы!
Новое имя: {1}</value>
  </data>
  <data name="Change_PathWarning" xml:space="preserve">
    <value>Зафиксировано изменение пути для команды ({0}).
Внимание: Change не проверяет путь!
Новый путь: {1}</value>
  </data>
  <data name="Change_TypeWarning" xml:space="preserve">
    <value>Зафиксировано изменение типа для команды ({0}).
Внимание: Это изменит каким образом команда выполняется!
Новый тип: {1}</value>
  </data>
  <data name="Change_ShellWarning" xml:space="preserve">
    <value>Зафиксировано изменение окружения для команды ({0}).
Внимание: Это может сломать выполннение команды!
Новое окружение: {1}</value>
  </data>
  <data name="Change_OptionsWarning" xml:space="preserve">
    <value>Зафиксировано изменение опций для команды ({0}).
Внимание: Это может повлиять на выполнение команды!
Новые опции: {1}</value>
  </data>
  <data name="Change_NoChange" xml:space="preserve">
    <value>Вы не указали ничего что нужно изменить!
Используйте флаги для того чтобы указать изменяемые свойства.</value>
  </data>
  <data name="Change_NewCommandProfile" xml:space="preserve">
    <value>Был сформирован новый профиль команды:
name:
    old:{0}
    new:{1}
path:
    old:{2}
    new:{3}
type:
    old:{4}
    new:{5}
shell:
    old:{6}
    new:{7}
options:
    old:{8}
    new:{9}</value>
  </data>
  <data name="Change_Same" xml:space="preserve">
    <value>То же самое.</value>
  </data>
  <data name="Change_Warning" xml:space="preserve">
    <value>Команда готова для реконструирования и перезаписи.</value>
  </data>
  <!--

  Primes tool strings.

  -->
  <data name="Primes_Help" xml:space="preserve">
    <value>Этот инструмент использует простой алгоритм просеивания для того, чтобы выяснить количество простых чисел до заданного значения. 
Передел поиска задаётся через аргумент.
Поддерживает параллелизацию.
Флаги:
      --time              - выводит потраченное время вместе с результатом.
      --parallel [number] - устанавливает ограничение использования потоков.
      --no-parallel       - выполняет просеивание синхронно.
Использование:
      fcli prime 1000000 --time
      fcli pr 1000000 --parallel 6
</value>
  </data>
  <data name="Primes_NonNumberArg" xml:space="preserve">
    <value>Инструмент Primes может принимать только целое число в качестве аргумента.
Это число задаёт границу поиска простых чисел.</value>
  </data>
  <data name="Primes_NoParallelValue" xml:space="preserve">
    <value>Флаг --parallel должен указывать числом количество потоков, которое необходимо использовать.</value>
  </data>
  <data name="Primes_InvalidSize" xml:space="preserve">
    <value>Аргумент должен иметь значение большее 5.</value>
  </data>
  <data name="Primes_InvalidParallel" xml:space="preserve">
    <value>Флаг --parallel должен иметь значение большее 1.</value>
  </data>
  <data name="FCli_Starting" xml:space="preserve">
    <value>Просеивание начинается. Нажмите [q] чтобы отменить его.</value>
  </data>
  <data name="FCli_Results" xml:space="preserve">
    <value>Найдено [{0}] простых чисел до границы: {1}</value>
  </data>
  <data name="Primes_TimeElapsed" xml:space="preserve">
    <value>Затрачено времени: {0}</value>
  </data>

</root>